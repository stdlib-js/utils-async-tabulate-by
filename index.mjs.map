{"version":3,"file":"index.mjs","sources":["../lib/validate.js","../lib/limit.js","../lib/factory.js","../lib/main.js","../lib/index.js"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isObject from '@stdlib/assert-is-plain-object';\nimport hasOwnProp from '@stdlib/assert-has-own-property';\nimport { isPrimitive as isBoolean } from '@stdlib/assert-is-boolean';\nimport { isPrimitive as isPositiveInteger } from '@stdlib/assert-is-positive-integer';\nimport format from '@stdlib/error-tools-fmtprodmsg';\n\n\n// MAIN //\n\n/**\n* Validates function options.\n*\n* @private\n* @param {Object} opts - destination object\n* @param {Options} options - function options\n* @param {*} [options.thisArg] - execution context\n* @param {PositiveInteger} [options.limit] - maximum number of pending invocations at any one time\n* @param {boolean} [options.series] - boolean indicating whether to wait for a previous invocation to complete before invoking a provided function for the next element in a collection\n* @returns {(Error|null)} null or an error object\n*\n* @example\n* var opts = {};\n* var options = {\n*     'thisArg': {},\n*     'series': false,\n*     'limit': 10\n* };\n* var err = validate( opts, options );\n* if ( err ) {\n*     throw err;\n* }\n*/\nfunction validate( opts, options ) {\n\tif ( !isObject( options ) ) {\n\t\treturn new TypeError( format( '1Rj2V,FD', options ) );\n\t}\n\tif ( hasOwnProp( options, 'thisArg' ) ) {\n\t\topts.thisArg = options.thisArg;\n\t}\n\tif ( hasOwnProp( options, 'series' ) ) {\n\t\topts.series = options.series;\n\t\tif ( !isBoolean( opts.series ) ) {\n\t\t\treturn new TypeError( format( '1Rj2o,GE', 'series', opts.series ) );\n\t\t}\n\t}\n\tif ( hasOwnProp( options, 'limit' ) ) {\n\t\topts.limit = options.limit;\n\t\tif ( !isPositiveInteger( opts.limit ) ) {\n\t\t\treturn new TypeError( format( '1Rj3P,Fv', 'limit', opts.limit ) );\n\t\t}\n\t}\n\treturn null;\n}\n\n\n// EXPORTS //\n\nexport default validate;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar logger = require( 'debug' );\nimport indexOf from '@stdlib/utils-index-of';\n\n\n// VARIABLES //\n\nvar debug = logger( 'tabulate-by-async:limit' );\n\n\n// MAIN //\n\n/**\n* Invokes an indicator function once for each element in a collection, limiting the number of concurrently pending functions.\n*\n* @private\n* @param {Collection} collection - input collection\n* @param {Options} opts - function options\n* @param {*} [opts.thisArg] - execution context\n* @param {PositiveInteger} [opts.limit] - maximum number of pending function invocations\n* @param {Function} indicator - indicator function\n* @param {Callback} done - function to invoke upon completion or upon encountering an error\n* @returns {void}\n*/\nfunction limit( collection, opts, indicator, done ) {\n\tvar maxIndex;\n\tvar count;\n\tvar flg;\n\tvar lim;\n\tvar len;\n\tvar idx;\n\tvar out;\n\tvar tmp;\n\tvar i;\n\n\tlen = collection.length;\n\tdebug( 'Collection length: %d', len );\n\n\tout = [];\n\tif ( len === 0 ) {\n\t\tdebug( 'Finished processing a collection.' );\n\t\treturn done( null, out );\n\t}\n\ttmp = [];\n\tif ( len < opts.limit ) {\n\t\tlim = len;\n\t} else {\n\t\tlim = opts.limit;\n\t}\n\tdebug( 'Concurrency limit: %d', lim );\n\tdebug( 'Number of arguments: %d', indicator.length );\n\n\tmaxIndex = len - 1;\n\tcount = 0;\n\tidx = -1;\n\tfor ( i = 0; i < lim; i++ ) {\n\t\t// This guard is necessary to protect against synchronous functions which exhaust all collection elements...\n\t\tif ( idx < maxIndex ) {\n\t\t\tnext(); // eslint-disable-line node/callback-return\n\t\t}\n\t}\n\t/**\n\t* Callback to invoke a provided function for the next element in a collection.\n\t*\n\t* @private\n\t*/\n\tfunction next() {\n\t\tvar v;\n\t\tvar j;\n\n\t\tidx += 1;\n\t\tj = idx;\n\t\tv = collection[ j ];\n\n\t\tdebug( 'Collection element %d: %s.', j, JSON.stringify( v ) );\n\t\tif ( indicator.length === 2 ) {\n\t\t\tindicator.call( opts.thisArg, v, cb );\n\t\t} else if ( indicator.length === 3 ) {\n\t\t\tindicator.call( opts.thisArg, v, j, cb );\n\t\t} else {\n\t\t\tindicator.call( opts.thisArg, v, j, collection, cb );\n\t\t}\n\t\t/**\n\t\t* Callback invoked once a provided function finishes processing a collection element.\n\t\t*\n\t\t* @private\n\t\t* @param {*} [error] - error\n\t\t* @param {*} [group] - group\n\t\t* @returns {void}\n\t\t*/\n\t\tfunction cb( error, group ) {\n\t\t\tvar i;\n\t\t\tif ( flg ) {\n\t\t\t\t// Prevent further processing of collection elements:\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif ( error ) {\n\t\t\t\tflg = true;\n\t\t\t\treturn clbk( error );\n\t\t\t}\n\t\t\tdebug( 'Collection element %d group: %s.', j, group );\n\n\t\t\t// Determine if we've seen the group/category before. If not, cache a reference which points to its location in the output array; otherwise, update the running count.\n\t\t\ti = indexOf( tmp, group );\n\t\t\tif ( i === -1 ) {\n\t\t\t\ttmp.push( group );\n\t\t\t\tout.push( [ group, 1, 0 ] );\n\t\t\t} else {\n\t\t\t\tout[ i ][ 1 ] += 1;\n\t\t\t}\n\t\t\tclbk();\n\t\t}\n\t}\n\n\t/**\n\t* Callback invoked once ready to process the next collection element.\n\t*\n\t* @private\n\t* @param {*} [error] - error\n\t* @returns {void}\n\t*/\n\tfunction clbk( error ) {\n\t\tvar i;\n\t\tif ( error ) {\n\t\t\tdebug( 'Encountered an error: %s', error.message );\n\t\t\treturn done( error );\n\t\t}\n\t\tcount += 1;\n\t\tdebug( 'Processed %d of %d collection elements.', count, len );\n\t\tif ( idx < maxIndex ) {\n\t\t\treturn next();\n\t\t}\n\t\tif ( count === len ) {\n\t\t\t// Compute percentages...\n\t\t\tfor ( i = 0; i < out.length; i++ ) {\n\t\t\t\tout[ i ][ 2 ] = out[ i ][ 1 ] / count;\n\t\t\t}\n\t\t\tdebug( 'Finished processing a collection.' );\n\t\t\treturn done( null, out );\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default limit;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isFunction from '@stdlib/assert-is-function';\nimport isCollection from '@stdlib/assert-is-collection';\nimport format from '@stdlib/error-tools-fmtprodmsg';\nimport PINF from '@stdlib/constants-float64-pinf';\nimport validate from './validate.js';\nimport limit from './limit.js';\n\n\n// MAIN //\n\n/**\n* Returns a function for generating a frequency table according to an indicator function.\n*\n* ## Notes\n*\n* -   This function does **not** guarantee that execution is asynchronous. To do so, wrap the `done` callback in a function which either executes at the end of the current stack (e.g., `nextTick`) or during a subsequent turn of the event loop (e.g., `setImmediate`, `setTimeout`).\n*\n* -   The output frequency table is an array of arrays. Each sub-array corresponds to a unique value in the input collection and is structured as follows:\n*\n*     -   0: unique value\n*     -   1: value count\n*     -   2: frequency percentage\n*\n* @param {Options} [options] - function options\n* @param {*} [options.thisArg] - execution context\n* @param {PositiveInteger} [options.limit] - maximum number of pending invocations at any one time\n* @param {boolean} [options.series=false] - boolean indicating whether to wait for a previous invocation to complete before invoking a provided function for the next element in a collection\n* @param {Function} indicator - function whose return values are used to populate the output frequency table\n* @throws {TypeError} options argument must be an object\n* @throws {TypeError} must provide valid options\n* @throws {TypeError} last argument must be a function\n* @returns {Function} function which invokes the indicator function once for each element in a collection\n*\n* @example\n* import readFile from '@stdlib/fs-read-file';\n*\n* function indicator( file, next ) {\n*     var opts = {\n*         'encoding': 'utf8'\n*     };\n*     readFile( file, opts, onFile );\n*\n*     function onFile( error ) {\n*         if ( error ) {\n*             return next( null, 'nonreadable' );\n*         }\n*         next( null, 'readable' );\n*     }\n* }\n*\n* var opts = {\n*     'series': true\n* };\n*\n* // Create a `tabulateByAsync` function which invokes the indicator function for each collection element sequentially:\n* var tabulateByAsync = factory( opts, indicator );\n*\n* // Create a collection over which to iterate:\n* var files = [\n*     './beep.js',\n*     './boop.js'\n* ];\n*\n* // Define a callback which handles results:\n* function done( error, result ) {\n*     if ( error ) {\n*         throw error;\n*     }\n*     console.log( result );\n* }\n*\n* // Try to read each element in `files`:\n* tabulateByAsync( files, done );\n*/\nfunction factory( options, indicator ) {\n\tvar opts;\n\tvar err;\n\tvar f;\n\n\topts = {};\n\tif ( arguments.length > 1 ) {\n\t\terr = validate( opts, options );\n\t\tif ( err ) {\n\t\t\tthrow err;\n\t\t}\n\t\tf = indicator;\n\t} else {\n\t\tf = options;\n\t}\n\tif ( !isFunction( f ) ) {\n\t\tthrow new TypeError( format( '1Rj3q,JV', f ) );\n\t}\n\tif ( opts.series ) {\n\t\topts.limit = 1;\n\t} else if ( !opts.limit ) {\n\t\topts.limit = PINF;\n\t}\n\treturn tabulateByAsync;\n\n\t/**\n\t* Invokes an indicator function for each element in a collection.\n\t*\n\t* @private\n\t* @param {Collection} collection - input collection\n\t* @param {Callback} done - function to invoke upon completion\n\t* @throws {TypeError} first argument must be a collection\n\t* @throws {TypeError} last argument must be a function\n\t* @returns {void}\n\t*/\n\tfunction tabulateByAsync( collection, done ) {\n\t\tif ( !isCollection( collection ) ) {\n\t\t\tthrow new TypeError( format( '1RjAh,O3', collection ) );\n\t\t}\n\t\tif ( !isFunction( done ) ) {\n\t\t\tthrow new TypeError( format( '1Rj3q,JV', done ) );\n\t\t}\n\t\treturn limit( collection, opts, f, clbk );\n\n\t\t/**\n\t\t* Callback invoked upon completion.\n\t\t*\n\t\t* @private\n\t\t* @param {*} [error] - error\n\t\t* @param {Object} result - frequency table\n\t\t* @returns {void}\n\t\t*/\n\t\tfunction clbk( error, result ) {\n\t\t\tif ( error ) {\n\t\t\t\treturn done( error );\n\t\t\t}\n\t\t\tdone( null, result );\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default factory;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport factory from './factory.js';\n\n\n// MAIN //\n\n/**\n* Generates a frequency table according to an indicator function.\n*\n* ## Notes\n*\n* -   This function does **not** guarantee that execution is asynchronous. To do so, wrap the `done` callback in a function which either executes at the end of the current stack (e.g., `nextTick`) or during a subsequent turn of the event loop (e.g., `setImmediate`, `setTimeout`).\n*\n* -   The output frequency table is an array of arrays. Each sub-array corresponds to a unique value in the input collection and is structured as follows:\n*\n*     -   0: unique value\n*     -   1: value count\n*     -   2: frequency percentage\n*\n* @param {Collection} collection - input collection\n* @param {Options} [options] - function options\n* @param {*} [options.thisArg] - execution context\n* @param {PositiveInteger} [options.limit] - maximum number of pending invocations at any one time\n* @param {boolean} [options.series=false] - boolean indicating whether to wait for a previous invocation to complete before invoking a provided function for the next element in a collection\n* @param {Function} indicator - function whose return values are used to populate the output frequency table\n* @param {Callback} done - function to invoke upon completion\n* @throws {TypeError} first argument must be a collection\n* @throws {TypeError} options argument must be an object\n* @throws {TypeError} must provide valid options\n* @throws {TypeError} second-to-last argument must be a function\n* @throws {TypeError} last argument must be a function\n* @returns {void}\n*\n* @example\n* import readFile from '@stdlib/fs-read-file';\n*\n* function done( error, result ) {\n*     if ( error ) {\n*         throw error;\n*     }\n*     console.log( result );\n* }\n*\n* function indicator( file, next ) {\n*     var opts = {\n*         'encoding': 'utf8'\n*     };\n*     readFile( file, opts, onFile );\n*\n*     function onFile( error ) {\n*         if ( error ) {\n*             return next( null, 'nonreadable' );\n*         }\n*         next( null, 'readable' );\n*     }\n* }\n*\n* var files = [\n*     './beep.js',\n*     './boop.js'\n* ];\n*\n* tabulateByAsync( files, indicator, done );\n*/\nfunction tabulateByAsync( collection, options, indicator, done ) {\n\tif ( arguments.length < 4 ) {\n\t\treturn factory( options )( collection, indicator );\n\t}\n\tfactory( options, indicator )( collection, done );\n}\n\n\n// EXPORTS //\n\nexport default tabulateByAsync;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* Generate a frequency table according to an indicator function.\n*\n* @module @stdlib/utils-async-tabulate-by\n*\n* @example\n* import readFile from '@stdlib/fs-read-file';\n* import tabulateByAsync from '@stdlib/utils-async-tabulate-by';\n*\n* var files = [\n*     './beep.js',\n*     './boop.js'\n* ];\n*\n* function done( error, result ) {\n*     if ( error ) {\n*         throw error;\n*     }\n*     console.log( result );\n* }\n*\n* function indicator( file, next ) {\n*     var opts = {\n*         'encoding': 'utf8'\n*     };\n*     readFile( file, opts, onFile );\n*\n*     function onFile( error ) {\n*         if ( error ) {\n*             return next( null, 'nonreadable' );\n*         }\n*         next( null, 'readable' );\n*     }\n* }\n*\n* tabulateByAsync( files, indicator, done );\n*/\n\n// MODULES //\n\nimport setReadOnly from '@stdlib/utils-define-nonenumerable-read-only-property';\nimport main from './main.js';\nimport factory from './factory.js';\n\n\n// MAIN //\n\nsetReadOnly( main, 'factory', factory );\n\n\n// EXPORTS //\n\nexport default main;\n"],"names":["validate","opts","options","isObject","hasOwnProp","thisArg","series","isBoolean","TypeError","format","limit","isPositiveInteger","debug","logger","collection","indicator","done","maxIndex","count","flg","lim","len","idx","out","tmp","i","length","next","v","j","cb","error","group","clbk","indexOf","push","JSON","stringify","call","message","factory","err","f","arguments","isFunction","PINF","tabulateByAsync","isCollection","result","setReadOnly","main"],"mappings":"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"}